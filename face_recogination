"""Face recognition functions for capturing and recognizing faces."""

import os
from typing import List, Optional, Tuple

import cv2
import numpy as np

FACES_DIR = "data/faces"
MODEL_PATH = "data/model_lbph.xml"
FACE_SIZE = (200, 200)


def get_face_detector():
	"""Get face detector."""
	path = cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
	detector = cv2.CascadeClassifier(path)
	if detector.empty():
		raise RuntimeError("Could not load face detector.")
	return detector


def prepare_face(gray_img, x, y, w, h):
	"""Extract and resize face from image."""
	face = gray_img[y:y+h, x:x+w]
	return cv2.resize(face, FACE_SIZE)


def capture_faces(cid: str, num_samples: int = 15) -> None:
	"""Capture face photos from webcam."""
	os.makedirs(f"{FACES_DIR}/{cid}", exist_ok=True)
	
	detector = get_face_detector()
	camera = cv2.VideoCapture(0)
	if not camera.isOpened():
		raise RuntimeError("Could not access camera.")
	
	print("Look at camera. Press 'q' to stop.")
	count = 0
	while count < num_samples:
		ok, frame = camera.read()
		if not ok:
			continue
		
		gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
		faces = detector.detectMultiScale(gray, 1.2, 5, minSize=(100, 100))
		
		for x, y, w, h in faces:
			face_img = prepare_face(gray, x, y, w, h)
			path = f"{FACES_DIR}/{cid}/{count+1}.jpg"
			cv2.imwrite(path, face_img)
			count += 1
			print(f"Saved {path}")
			if count >= num_samples:
				break
		
		cv2.imshow("Press 'q' to quit", frame)
		if cv2.waitKey(1) & 0xFF == ord("q"):
			break
	
	camera.release()
	cv2.destroyAllWindows()
	print(f"Captured {count} images.")


def load_training_data() -> Tuple[List, List]:
	"""Load all face images for training."""
	images = []
	labels = []
	
	if not os.path.isdir(FACES_DIR):
		return images, labels
	
	for cid in os.listdir(FACES_DIR):
		folder = f"{FACES_DIR}/{cid}"
		if not os.path.isdir(folder):
			continue
		
		for filename in os.listdir(folder):
			if not filename.lower().endswith((".jpg", ".png", ".jpeg")):
				continue
			
			img = cv2.imread(f"{folder}/{filename}", cv2.IMREAD_GRAYSCALE)
			if img is None:
				continue
			
			if img.shape != FACE_SIZE:
				img = cv2.resize(img, FACE_SIZE)
			
			images.append(img)
			labels.append(int(cid))
	
	return images, labels


def train_model() -> None:
	"""Train face recognition model."""
	if not hasattr(cv2, "face"):
		raise RuntimeError("Install opencv-contrib-python")
	
	images, labels = load_training_data()
	if not images:
		raise RuntimeError("No face photos found. Capture faces first.")
	
	os.makedirs("data", exist_ok=True)
	recognizer = cv2.face.LBPHFaceRecognizer_create()
	recognizer.train(images, np.array(labels))
	recognizer.write(MODEL_PATH)
	print(f"Model trained and saved.")


def recognize_face() -> Optional[int]:
	"""Recognize face from webcam."""
	if not hasattr(cv2, "face"):
		raise RuntimeError("Install opencv-contrib-python")
	
	if not os.path.exists(MODEL_PATH):
		raise RuntimeError("Model not found. Train model first.")
	
	recognizer = cv2.face.LBPHFaceRecognizer_create()
	recognizer.read(MODEL_PATH)
	detector = get_face_detector()
	camera = cv2.VideoCapture(0)
	
	if not camera.isOpened():
		raise RuntimeError("Could not access camera.")
	
	predicted_id = None
	best_conf = float("inf")
	
	print("Look at camera. Press 'q' when done.")
	while True:
		ok, frame = camera.read()
		if not ok:
			continue
		
		gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
		faces = detector.detectMultiScale(gray, 1.2, 5, minSize=(100, 100))
		
		for x, y, w, h in faces:
			face_img = prepare_face(gray, x, y, w, h)
			label, conf = recognizer.predict(face_img)
			
			if conf < best_conf:
				best_conf = conf
				predicted_id = label
			
			cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
			cv2.putText(frame, f"ID:{label}", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
		
		cv2.imshow("Press 'q' to finish", frame)
		if cv2.waitKey(1) & 0xFF == ord("q"):
			break
	
	camera.release()
	cv2.destroyAllWindows()
	return predicted_id

